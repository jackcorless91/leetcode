# Leetcode 15

## Question:

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j, i != k, and j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.


### Example 1:

Input: nums = `[-1,0,1,2,-1,-4]`  
Output: `[[-1,-1,2],[-1,0,1]]`  
#### Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.  
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.  
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.  
The distinct triplets are [-1,0,1] and [-1,-1,2].  
Notice that the order of the output and the order of the triplets does not matter.  

### Example 2:

Input: nums = `[0,1,1]`  
Output: `[]`   
#### Explanation:   
The only possible triplet does not sum up to 0.


## O(n^2) Solution:
This is a very long solution but it makes sense once broken down. We need to return triplets that equal `0`. We know `nums[i] + nums[j] + nums[k] == 0` so if we transpose and solve for `i` we get `nums[j] + nums[k] == -nums[i]`, this will equal `0`. This is going to be a two pointer solution similar to two Sum II but run within a for loop that iterates `i` for every pair in the array checked also reinitialsing `j` and `k`. 

First sort the array is ascending order, essential for two pointer solution. If `j` if slow pointer and `k` is fast we need if we need a smaller value we can decrement `k` and vice versa.

```javascript
nums.sort((a, b) => a - b);
```

Next we create an empty answer array `ans` to push the triplets when we find them. as well as start the outer loop.   
This will run as long as `i < n - 2` , this is because we need 3 distinct indices, if our two pointers `j` and `k` are at the end of the array `i` can't overlap them so it final position must be at `n - 2`.
```javascript
  const n = nums.length;
  const ans = [];

  for (let i = 0; i < n - 2; i++) {
  }
```
Before we start the inner loop we need to check for duplicates of `i` by checking itself against its previous value, we don't skip `i` manually when we find a duplicate we skip the iteration.  
`j` and `k` are also initalised at the start (account for `i`) and the end of the array.

```javascript
for (let i = 0; i < n - 2; i++) {
  if (i > 0 && nums[i] === nums[i - 1]) continue;

  let j = i + 1;
  let k = n - 1;
}
```

The main inner loop runs while `j` is less than `k` checking every possible pair. THis is two sum but with a moving target `i`. Also create variables described at the start.

```javascript
while (j < k) {
  let sum = nums[j] + nums[k];
  let target = -nums[i];
}
```

Inside the main loop we set the conditions for incrementing and decrementing `i` and `j`, while accounting for duplicate values.   
if the `sum` is less than the `target` we increment `j` by `1`, after being sorted at the start we know the next index if `j` will be greater than the previous making the `sum` greater. Same goes for decrementing `j`, if the `sum` is larger than the `target` we move k backwards.   
If we find a valid triplet we push it to the `ans` array and increment and decrement `j` and `k`, there could be more pairs for the current `target` so we can't skip the rest of the iteration.   
We also check for duplicates, so if we find the current index of `j` equal to the previous index of `j` we got a duplicate so move `j`, same for `k`. if the next index is equal, in this case the higher index because we're decrementing then move to the next value.

```javascript
if (sum < target) {
    j++;
} else if (sum > target) {
    k--;
} else {
    ans.push([nums[i], nums[j], nums[k]])
    j++;
    k--;
    while (j < k && nums[j] === nums[j - 1]) {
        j++;
    }
    while (j < k && nums[k] === nums[k + 1]) {
        k++;
    }
}
```

Finally return the answer array.

```javascript
return ans;
```

## Full Code:
```javascript
var threeSum = function(nums) {

    nums.sort((a, b) => a - b);

    const n = nums.length;
    const ans = [];

    for (let i = 0; i < n - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;

        let j = i + 1;
        let k = n - 1;

        while (j < k) {
            let sum = nums[j] + nums[k];
            let target = -nums[i];

            if (sum < target) {
                j++;
            } else if (sum > target) {
                k--;
            } else {
                ans.push([nums[i], nums[j], nums[k]])
                j++;
                k--;
                while (j < k && nums[j] === nums[j - 1]) {
                    j++;
                }
                while (j < k && nums[k] === nums[k + 1]) {
                    k++;
                }
            }
        }
    }
    return ans;
};
```
